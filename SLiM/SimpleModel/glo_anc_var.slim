// This code creates two different populations, marks one of them with mutations at regular intervals, and then proceeds to admixture them for 19 generations, keeping tab of the variance in global ancestry between chromosomes

// Initialize simulation
initialize() {
	// Custom parameters	
	if (!exists("LENGTH")) 		defineConstant("LENGTH", 3e9);
	if (!exists("SCALE")) 		defineConstant("SCALE", asInteger(2e5));
	if (!exists("POP1SIZE"))	defineConstant("POP1SIZE", 500);
	if (!exists("POP2SIZE"))	defineConstant("POP2SIZE", POP1SIZE);
	
	// Fixed parameters
	initializeMutationType("m1", 0.5, "f", 0.0); // p1 marker
	initializeMutationType("m2", 0.5, "f", 0.0); // Placeholder mutation
	c(m1,m2).convertToSubstitution = F;
	initializeGenomicElementType("g1", m2, 1.0);
	initializeGenomicElement(g1, 0, LENGTH);
	initializeMutationRate(0);
	
	// Recombination
	rates = 1e-8;
	while (size(rates) < 39) rates = c(rates, 0.5, 1e-8);	
	
	endsChr = seq(150000000, 3000000000, by = 150000000);
	endsBetween = seq(150000001, 2850000001, by = 150000000);
	
	ends = NULL;
	for (i in 0:(size(endsChr)-1))
	{
		ends = c(ends, endsChr[i]);
		if (i!=19) ends = c(ends, endsBetween[i]);
	}
	
	initializeRecombinationRate(rates, ends=ends); // Recombination rate of 1cM per Mbg, 20 chromosomes
}

// 1st cycle: setting up parental populations and adding marker mutations 
1 early() {
	sim.addSubpop("p1", POP1SIZE);
	sim.addSubpop("p2", POP2SIZE);
}

1 late() {
	// Set up marker positions
	positions = seq(from=0, to=LENGTH-1, by=SCALE);
	catn("Modeling a " + LENGTH + " bp chromosome with " + asInteger(LENGTH/SCALE) + " ancestry markers \n");
	
	// Add markers to only one of the subpopulations
	haplosomes1 = p1.haplosomes;
	haplosomes1.addNewDrawnMutation(m1, positions);
	
	// Fetching the list of markers type 1 markers for later use in the ancVar function
	muts_of_type_m1 = unique(p1.sampleIndividuals(1).haplosomes.mutationsOfType(m1));
	defineConstant("MutsType1", muts_of_type_m1);
}

// 2nd cycle: merging parental populations and first round of admixture (counted as generation 1 in simulation)
2 early() {
	defineConstant("POP3SIZE", POP1SIZE + POP2SIZE);
	sim.addSubpop("p3", POP3SIZE);
	p3.setMigrationRates(c(p1, p2), c(0.5, 0.5));
}

2 late() {
	p3.setMigrationRates(c(p1, p2), c(0.0, 0.0));
	p1.setSubpopulationSize(0);
	p2.setSubpopulationSize(0);
}

// Outputing ancestry correlation stats
2:40 late() {
	ancVar(p3, MutsType1, (POP1SIZE/POP3SIZE));
}

40 late() {
	sim.simulationFinished();
}

// Defining the function for calculating the variance in haplosome ancestry
function (void)ancVar(io<Subpopulation>$ subpopulation, o mutationList, numeric parentalProportion)
{
	// Defining haplosomes in population
	haplosomes = subpopulation.haplosomes;
	
	// Defining external vector for storage of global ancestries
	
	globalAncestries = NULL;
	
	// Loop for collecting ancestry information from the position and global ancestry
	for (hap in haplosomes)
	{
		vectorOfMutationPresence = asInteger(hap.containsMutations(mutationList));
		
		globalAncestries = c(globalAncestries, mean(vectorOfMutationPresence));
	}
	
	// Calculating the variance in global ancestry
	ancVar = var(globalAncestries);
	
	// Printing output
	if (sim.cycle == 2)
		catn("Variance (non-normalized) in global ancestry for all chromosomes -\nGEN " + (sim.cycle-1) + ": " + ancVar);
	else
		catn("GEN " + (sim.cycle-1) + ": " + ancVar);
}